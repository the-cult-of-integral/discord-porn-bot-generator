"""
Bot generated by the-cult-of-integral
https://github.com/the-cult-of-integral/discord-porn-bot-generator
"""

import logging
import sqlite3

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                    datefmt='%d-%b-%y %H:%M:%S', filename='LOG.log', filemode='w')


class Databases:
    def __init__(self) -> None:
        """
        Constructor
        """
        self.connection = sqlite3.connect('DB_NAME')
        self.cursor = self.connection.cursor()
        return

    def add_new_guild(self, guild_id) -> bool:
        """
        Add a new server to the database
        """
        sql = """INSERT INTO Servers(server_id) VALUES (?)"""
        if not (self.__exec_nonselect(sql, guild_id)):
            logging.error(
                'There has been an error during the ADD_NEW_GUILD function.')
            return False

        sql = """INSERT INTO Metrics(server_id) VALUES (?)"""
        if not (self.__exec_nonselect(sql, guild_id)):
            logging.error(
                'There has been an error during the ADD_NEW_GUILD function.')
            return False
        
        sql = """INSERT INTO NSFWConfigs(server_id) VALUES (?)"""
        if not (self.__exec_nonselect(sql, guild_id)):
            logging.error(
                'There has been an error during the ADD_NEW_GUILD function.')
            return False

        return True

    def get_link(self, category) -> list:
        """
        Get a random link_id and its link_url from the Links table, based on category
        """
        sql = 'SELECT link_id, link_url FROM Links WHERE link_category = ? ORDER BY RANDOM() LIMIT 1;'
        if self.__exec_select(sql, category):
            return self.cursor.fetchall()
        else:
            logging.error(
                'There has been an error during the GET_LINK function.')
            return []

    def get_link_by_id(self, link_id) -> str:
        """
        Get a link by its id
        """
        sql = "SELECT link_url FROM links WHERE link_id = ?;"
        if not (self.__exec_select(sql, link_id)):
            logging.error(
                'There has been an error during the GET_LINK_BY_ID function.')
            return ''
        else:
            temp = self.cursor.fetchone()
            if len(temp) > 0:
                return temp[0]
            else:
                return ''

    def check_category_enabled(self, category, guild_id) -> bool:
        """
        Check whether a command (category) is enabled
        """
        category = self.get_cmd_bool(category)
        sql = f"SELECT {category} FROM NSFWConfigs WHERE server_id = (?);"
        if not (self.__exec_select(sql, guild_id)):
            logging.error(
                'There has been an error during the CHECK_LINK_ENABLED function.'
            )
            return False
        else:
            temp = self.cursor.fetchone()
            if len(temp) > 0:
                if temp[0]:
                    return True
            return False

    def check_link_prev(self, link_id, category, guild_id) -> bool:
        """
        Checks whether a link was used on the previous command
        """
        sql = f"SELECT {category}_prev_link FROM Metrics WHERE server_id = (?);"
        if not (self.__exec_select(sql, guild_id)):
            logging.error(
                'There has been an error during the CHECK_LINK_PREV function.')
            return False
        else:
            temp = self.cursor.fetchone()
            if len(temp) > 0:
                if not (link_id == temp[0]):
                    return True
            return False

    def check_only_nsfw(self, guild_id) -> bool:
        """
        Check if commands are restricted to NSFW channels only
        """
        sql = "SELECT onlyNSFW FROM NSFWConfigs WHERE server_id = (?)"
        if not (self.__exec_select(sql, guild_id)):
            logging.error(
                'There has been an error during the CHECK_ONLY_NSFW function.')
            return False
        else:
            temp = self.cursor.fetchone()
            if len(temp) > 0:
                if temp[0]:
                    return True
                else:
                    return False
            return False

    def get_cmd_bool(self, category) -> str:
        """
        Get cmd_bool in NSFWConfigs table from category string
        """
        category = list(category.lower())
        category.insert(0, 'do')
        category[1] = category[1].upper()
        return ''.join(category)

    def update_config(self, cfgk, cfgv, guild_id) -> bool:
        """
        Update config tables
        """
        sql = f"UPDATE NSFWConfigs SET {cfgk} = (?) WHERE server_id = (?)"
        if not (self.__exec_nonselect(sql, cfgv, guild_id)):
            logging.error(
                'There has been an error during the UPDATE_CONFIG function.'
            )
            return False
        return True

    def update_prev_link(self, link_id, category, guild_id) -> bool:
        """
        Update the previous link in the Metrics table
        """
        sql = f"UPDATE Metrics SET {category}_prev_link = (?) WHERE server_id = (?)"
        if not (self.__exec_nonselect(sql, link_id, guild_id)):
            logging.error(
                'There has been an error during the UPDATE_PREV_LINK function.'
            )
            return False
        return True

    def __exec_select(self, sql, *args) -> bool:
        """
        Small Cursor.execution function for SELECT queries.
        """
        try:
            self.cursor.execute(sql, args)
        except sqlite3.Error as e:
            logging.error(e)
            return False
        return True

    def __exec_nonselect(self, sql, *args) -> bool:
        """
        Small Cursor.execution function for non-SELECT queries.
        """
        try:
            self.cursor.execute(sql, args)
            self.connection.commit()
        except sqlite3.Error as e:
            logging.error(e)
            return False
        return True

    def __del__(self) -> None:
        """
        Destructor
        """
        self.cursor.close()
        self.connection.close()
        del self.cursor
        del self.connection
        return
